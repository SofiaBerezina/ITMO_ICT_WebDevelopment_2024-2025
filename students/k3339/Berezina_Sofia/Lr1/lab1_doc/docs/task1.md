# Задание № 1. Реализация UDP клиент-серверного приложения

## Задача

В рамках данного задания мне предстояло реализовать простое клиент-серверное приложение с использованием протокола UDP и библиотеки socket в Python. Основная задача заключалась в организации обмена сообщениями между клиентом и сервером: клиент отправляет сообщение "Hello, server", сервер принимает его, отображает на своей стороне и отправляет ответ "Hello, client", который должен отобразиться у клиента.

## Ход работы

Перед началом реализации я изучил основные принципы работы протокола UDP (User Datagram Protocol). В отличие от TCP, UDP является протоколом без установки соединения, что означает отсутствие предварительного "рукопожатия" между клиентом и сервером. Это делает UDP более быстрым, но менее надежным - пакеты могут теряться или приходить в неправильном порядке. Однако для простого обмена сообщениями в локальной сети UDP вполне подходит.

Библиотека socket в Python предоставляет необходимые инструменты для работы с сетевыми соединениями. Для UDP требуется создать сокет с параметрами AF_INET (IPv4) и SOCK_DGRAM (датаграммы).

### 1. Реализация серверной части

Серверную часть я начала с создания UDP сокета. Использовала конструктор socket.socket() с параметрами socket.AF_INET и socket.SOCK_DGRAM, что соответствует UDP протоколу над IPv4. 

Далее необходимо было привязать сокет к конкретному адресу и порту. Я выбрала адрес '127.0.0.1' (localhost) и порт 14900. Метод bind() фиксирует сокет на этом адресе, после чего сервер начинает "слушать" входящие сообщения.

Для приема данных использовала метод recvfrom(16384), где 16384 - это размер буфера для приема данных. Этот метод блокирует выполнение программы до тех пор, пока не поступят данные от клиента. Полученные данные возвращаются в виде кортежа, где первый элемент - сами данные в байтах, а второй - адрес отправителя.

После получения сообщения я декодировала байты в строку с помощью decode('utf-8') и вывел его на экран. Затем отправила ответ клиенту используя метод send(), передав в него сообщение "Hello, client" в байтовом формате и адрес клиента, полученный из recvfrom().

В конце закрыла соединение с помощью close().

```python
import socket

conn = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
conn.bind(('127.0.0.1', 14900))

data = conn.recvfrom(16384)
udata = data[0].decode('utf-8')
print(f'Message: {udata}')
print('Response: Hello, client')

conn.close()
```

### 2. Реализация клиентской части

Клиентская часть также начинается с создания UDP сокета аналогично серверу. Однако вместо bind() я использовала метод connect(), который в случае UDP не устанавливает соединение, а лишь задает адрес по умолчанию для последующих операций send() и recv().

Для отправки сообщения серверу использовала метод send() с сообщением "Hello, server", предварительно преобразованным в байты с помощью префикса b. После отправки клиент ожидает ответ от сервера с помощью recv(16384), декодирует полученные байты и выводит сообщение на экран.

```python
import socket

conn = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
conn.connect(("127.0.0.1", 14900))

conn.send(b'Hello, server')
```
